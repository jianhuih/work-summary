## 3.3 Activity启动流程

### 3.3.1 简介
startActivity流程比较复杂，我们首先从调用方开始，其调用轨迹基本如下所是：
```
Activity.startActivity -->
  ContextImpl.execStartActivity -->
    Instrumentation.startActivity -->
      ActivityManagerService.startActivity
```
经过层层中转后，startActivity最终在AMS中实现，接下来我们看一下相关代码：

### 3.3.2 AMS进程
在AMS中，首先要解决目标Intent：
```Java
//ActivityManagerService.java
public final int startActivity(IApplicationThread caller, String callingPackage,
        Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
        int startFlags, ProfilerInfo profilerInfo, Bundle options) {
    return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,
        resultWho, requestCode, startFlags, profilerInfo, options,
        UserHandle.getCallingUserId());
}
public final int startActivityAsUser(IApplicationThread caller, String callingPackage,
    Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
    int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) {
    enforceNotIsolatedCaller("startActivity");
    userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,
            false, ALLOW_FULL_ONLY, "startActivity", null);
    return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent,
            resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,
            profilerInfo, null, null, options, false, userId, null, null);
}
//ActivityStackSupervisor.java
final int startActivityMayWait(IApplicationThread caller, int callingUid,
        String callingPackage, Intent intent, String resolvedType,
        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
        IBinder resultTo, String resultWho, int requestCode, int startFlags,
        ProfilerInfo profilerInfo, WaitResult outResult, Configuration config,
        Bundle options, boolean ignoreTargetSecurity, int userId,
        IActivityContainer iContainer, TaskRecord inTask) {
    ...
    boolean componentSpecified = intent.getComponent() != null;
    intent = new Intent(intent);

    //解决Intent所指向的Activity信息，当存在多个可供选择的Activity，则直接向用户弹出，由用户选择
    ActivityInfo aInfo = resolveActivity(intent, resolvedType, startFlags, profilerInfo, userId);

    synchronized (mService) {
        ...
        int res = startActivityLocked(caller, intent, resolvedType, aInfo,
                voiceSession, voiceInteractor, resultTo, resultWho,
                requestCode, callingPid, callingUid, callingPackage,
                realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity,
                componentSpecified, null, container, inTask);
        ...        
        return res;
    }
}
```
其中startActivityAsUser主要是做一些权限检查，而startActivityMayWait里主要是匹配符合Intent要求的Activity，如果是显式Intent，则直接就解决了；如果是隐式，则通过PackageManagerService查找到匹配的Activity，具体实现可以参见resolveActivity中，这里就不再详述了。匹配到合适的Activity后，就调用startActivityLocked方法：
```Java
//ActivityStackSupervisor.java
final int startActivityLocked(IApplicationThread caller,
        Intent intent, String resolvedType, ActivityInfo aInfo, IBinder resultTo,
        String resultWho, int requestCode,
        int callingPid, int callingUid, String callingPackage, int startFlags, Bundle options,
        boolean componentSpecified, ActivityRecord[] outActivity) {
    int err = ActivityManager.START_SUCCESS;
    ProcessRecord callerApp = null;
    //获取调用者的进程记录
    if (caller != null) {
        callerApp = mService.getRecordForAppLocked(caller);
        if (callerApp != null) {
            callingPid = callerApp.pid;
            callingUid = callerApp.info.uid;
        } else {
            err = ActivityManager.START_PERMISSION_DENIED;
        }
    }

    if (err == ActivityManager.START_SUCCESS) {
        final int userId = aInfo != null ? UserHandle.getUserId(aInfo.applicationInfo.uid) : 0;
    }
    ActivityRecord sourceRecord = null;
    ActivityRecord resultRecord = null;
    if (resultTo != null) {
        sourceRecord = isInAnyStackLocked(resultTo);
        if (sourceRecord != null) {
            if (requestCode >= 0 && !sourceRecord.finishing) {
                resultRecord = sourceRecord;
            }
        }
    }
    ActivityStack resultStack = resultRecord == null ? null : resultRecord.task.stack;
    //处理result跨Activity传递
    int launchFlags = intent.getFlags();
    if ((launchFlags&Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0
            && sourceRecord != null) {
        if (requestCode >= 0) {
            ActivityOptions.abort(options);
            return ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;
        }
        resultRecord = sourceRecord.resultTo;
        resultWho = sourceRecord.resultWho;
        requestCode = sourceRecord.requestCode;
        sourceRecord.resultTo = null;
        if (resultRecord != null) {
            resultRecord.removeResultsLocked(sourceRecord, resultWho, requestCode);
        }
    }

    //Intent未能成功解决
    if (err == ActivityManager.START_SUCCESS && intent.getComponent() == null) {
        err = ActivityManager.START_INTENT_NOT_RESOLVED;
    }
    if (err == ActivityManager.START_SUCCESS && aInfo == null) {
        err = ActivityManager.START_CLASS_NOT_FOUND;
    }
    if (err != ActivityManager.START_SUCCESS) {
        if (resultRecord != null) {
            resultStack.sendActivityResultLocked(-1,
                resultRecord, resultWho, requestCode,
                Activity.RESULT_CANCELED, null);
        }
        setDismissKeyguard(false);
        ActivityOptions.abort(options);
        return err;
    }

    //调用者权限检查
    final int startAnyPerm = mService.checkPermission(START_ANY_ACTIVITY, callingPid, callingUid);
    final int componentPerm = mService.checkComponentPermission(aInfo.permission, callingPid,
            callingUid, aInfo.applicationInfo.uid, aInfo.exported);
    if (startAnyPerm != PERMISSION_GRANTED && componentPerm != PERMISSION_GRANTED) {
        if (resultRecord != null) {
            resultStack.sendActivityResultLocked(-1,
                resultRecord, resultWho, requestCode,
                Activity.RESULT_CANCELED, null);
        }
        setDismissKeyguard(false);

    }
    ...
    //创建ActivityRecord对象
    ActivityRecord r = new ActivityRecord(mService, callerApp, callingUid, callingPackage,
            intent, resolvedType, aInfo, mService.mConfiguration,
            resultRecord, resultWho, requestCode, componentSpecified, this);
    if (outActivity != null) {
        outActivity[0] = r;
    }
    final ActivityStack stack = getFocusedStack();
    if (stack.mResumedActivity == null
            || stack.mResumedActivity.info.applicationInfo.uid != callingUid) {
        if (!mService.checkAppSwitchAllowedLocked(callingPid, callingUid, "Activity start")) {
            PendingActivityLaunch pal = new PendingActivityLaunch(r, sourceRecord, startFlags, stack);
            mService.mPendingActivityLaunches.add(pal);
            setDismissKeyguard(false);
            ActivityOptions.abort(options);
            return ActivityManager.START_SWITCHES_CANCELED;
        }
    }
    ...
    mService.doPendingActivityLaunchesLocked(false);
    err = startActivityUncheckedLocked(r, sourceRecord, startFlags, true, options);
    ...
    return err;
}

```
该方法主要进行以下几个逻辑：首先确保调用者本身的进程是存在的，否则直接返回START_PERMISSION_DENIED错误；然后处理FLAG_ACTIVITY_FORWARD_RESULT这个标志；然后检查Intent是否成功解决，如果其中的ActivityInfo为空，则直接返回错误；然后检查调用者是否具有启动该Activity的权限，最后创建ActivityRecord对象。接下来我们详细分析一下startActivityUncheckedLocked方法，该方法主要是要给目标Activity安排一个合适的Task：
```Java
//ActivityStackSupervisor.java
final int startActivityUncheckedLocked(ActivityRecord r,
        ActivityRecord sourceRecord, int startFlags, boolean doResume,
        Bundle options) {
    final Intent intent = r.intent;
    final int callingUid = r.launchedFromUid;

    int launchFlags = intent.getFlags();
    ...

    //处理需要新建一个Task的情况
    if (sourceRecord == null) {
        if ((launchFlags&Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {
            launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;
        }
    } else if (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
        launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;
    } else if (r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE
            || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
        launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;
    }

    //如果新建一个Task，是无法传递结果的
    if (r.resultTo != null && (launchFlags&Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
        r.resultTo.task.stack.sendActivityResultLocked(-1,
                r.resultTo, r.resultWho, r.requestCode,
            Activity.RESULT_CANCELED, null);
        r.resultTo = null;
    }

    boolean addingToTask = false;
    boolean movedHome = false;
    TaskRecord reuseTask = null;
    ActivityStack targetStack;
    if (((launchFlags&Intent.FLAG_ACTIVITY_NEW_TASK) != 0 &&
            (launchFlags&Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0)
            || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK
            || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
        if (r.resultTo == null) {
            ActivityRecord intentActivity = r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE
                    ? findTaskLocked(r)
                    : findActivityLocked(intent, r.info);
            if (intentActivity != null) {
                if (r.task == null) {
                    r.task = intentActivity.task;
                }
                targetStack = intentActivity.task.stack;
                targetStack.mLastPausedActivity = null;
                moveHomeStack(targetStack.isHomeStack());
                if (intentActivity.task.intent == null) {
                    intentActivity.task.setIntent(intent, r.info);
                }
                final ActivityStack lastStack = getLastStack();
                ActivityRecord curTop = lastStack == null?
                        null : lastStack.topRunningNonDelayedActivityLocked(notTop);
                if (curTop != null && (curTop.task != intentActivity.task ||
                        curTop.task != lastStack.topTask())) {
                    r.intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
                    if (sourceRecord == null || (sourceStack.topActivity() != null &&
                            sourceStack.topActivity().task == sourceRecord.task)) {
                        movedHome = true;
                        if ((launchFlags &
                                (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME))
                                == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) {
                            intentActivity.task.mOnTopOfHome = true;
                        }
                        targetStack.moveTaskToFrontLocked(intentActivity.task, r, options);
                        options = null;
                    }
                }
                if ((launchFlags&Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) {
                    intentActivity = targetStack.resetTaskIfNeededLocked(intentActivity, r);
                }
                if ((startFlags&ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
                    if (doResume) {
                        resumeTopActivitiesLocked(targetStack, null, options);
                    } else {
                        ActivityOptions.abort(options);
                    }
                    return ActivityManager.START_RETURN_INTENT_TO_CALLER;
                }
                if ((launchFlags &
                        (Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_CLEAR_TASK))
                        == (Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_CLEAR_TASK)) {
                    reuseTask = intentActivity.task;
                    reuseTask.performClearTaskLocked();
                    reuseTask.setIntent(r.intent, r.info);
                } else if ((launchFlags&Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0
                        || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK
                        || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
                    ActivityRecord top = intentActivity.task.performClearTaskLocked(r, launchFlags);
                    if (top != null) {
                        if (top.frontOfTask) {
                            top.task.setIntent(r.intent, r.info);
                        }
                        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT, r, top.task);
                        top.deliverNewIntentLocked(callingUid, r.intent);
                    } else {
                        addingToTask = true;
                        sourceRecord = intentActivity;
                    }
                } else if (r.realActivity.equals(intentActivity.task.realActivity)) {
                    if (((launchFlags&Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0
                            || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP)
                            && intentActivity.realActivity.equals(r.realActivity)) {
                        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT, r, intentActivity.task);
                        if (intentActivity.frontOfTask) {
                            intentActivity.task.setIntent(r.intent, r.info);
                        }
                        intentActivity.deliverNewIntentLocked(callingUid, r.intent);
                    } else if (!r.intent.filterEquals(intentActivity.task.intent)) {
                        addingToTask = true;
                        sourceRecord = intentActivity;
                    }
                } else if ((launchFlags&Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) == 0) {
                    addingToTask = true;
                    sourceRecord = intentActivity;
                } else if (!intentActivity.task.rootWasReset) {
                    intentActivity.task.setIntent(r.intent, r.info);
                }
                if (!addingToTask && reuseTask == null) {
                    if (doResume) {
                        targetStack.resumeTopActivityLocked(null, options);
                    } else {
                        ActivityOptions.abort(options);
                    }
                    return ActivityManager.START_TASK_TO_FRONT;
                }
            }
        }
    }

    if (r.packageName != null) {
        //判断目标Activity是否是当前Task栈顶Activity
        ActivityStack topStack = getFocusedStack();
        ActivityRecord top = topStack.topRunningNonDelayedActivityLocked(notTop);
        if (top != null && r.resultTo == null) {
            if (top.realActivity.equals(r.realActivity) && top.userId == r.userId) {
                if (top.app != null && top.app.thread != null) {
                    if ((launchFlags&Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0
                        || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP
                        || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
                        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT, top, top.task);

                        topStack.mLastPausedActivity = null;
                        if (doResume) {
                            resumeTopActivitiesLocked();
                        }
                        ActivityOptions.abort(options);
                        if ((startFlags&ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) {
                            return ActivityManager.START_RETURN_INTENT_TO_CALLER;
                        }
                        top.deliverNewIntentLocked(callingUid, r.intent);
                        return ActivityManager.START_DELIVERED_TO_TOP;
                    }
                }
            }
        }
    } else {
        ...
        return ActivityManager.START_CLASS_NOT_FOUND;
    }

    boolean newTask = false;
    boolean keepCurTransition = false;

    if (r.resultTo == null && !addingToTask
            && (launchFlags&Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
        targetStack = adjustStackFocus(r);
        moveHomeStack(targetStack.isHomeStack());
        if (reuseTask == null) {
            r.setTask(targetStack.createTaskRecord(getNextTaskId(), r.info, intent, true),
                    null, true);
        } else {
            r.setTask(reuseTask, reuseTask, true);
        }
        newTask = true;
        ...
    } else if (sourceRecord != null) {
        TaskRecord sourceTask = sourceRecord.task;
        targetStack = sourceTask.stack;
        moveHomeStack(targetStack.isHomeStack());
        if (!addingToTask &&
                (launchFlags&Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0) {
            //处理FLAG_ACTIVITY_CLEAR_TOP
            ActivityRecord top = sourceTask.performClearTaskLocked(r, launchFlags);
            keepCurTransition = true;
            if (top != null) {
                ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT, r, top.task);
                top.deliverNewIntentLocked(callingUid, r.intent);
                targetStack.mLastPausedActivity = null;
                if (doResume) {
                    targetStack.resumeTopActivityLocked(null);
                }
                ActivityOptions.abort(options);
                return ActivityManager.START_DELIVERED_TO_TOP;
            }
        } else if (!addingToTask &&
                (launchFlags&Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != 0) {

            final ActivityRecord top = sourceTask.findActivityInHistoryLocked(r);
            if (top != null) {
                final TaskRecord task = top.task;
                task.moveActivityToFrontLocked(top);
                ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT, r, task);
                top.updateOptionsLocked(options);
                top.deliverNewIntentLocked(callingUid, r.intent);
                targetStack.mLastPausedActivity = null;
                if (doResume) {
                    targetStack.resumeTopActivityLocked(null);
                }
                return ActivityManager.START_DELIVERED_TO_TOP;
            }
        }
        r.setTask(sourceTask, sourceRecord.thumbHolder, false);
    }
    ...
    mService.grantUriPermissionFromIntentLocked(callingUid, r.packageName, intent, r.getUriPermissionsLocked());

    ActivityStack.logStartActivity(EventLogTags.AM_CREATE_ACTIVITY, r, r.task);
    targetStack.mLastPausedActivity = null;
    targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options);
    mService.setFocusedActivityLocked(r);
    return ActivityManager.START_SUCCESS;
}
```
该方法比较复杂主要是给目标Activity找到或者创建合适的Task，也就是处理LaunchMode和IntentFlag。接下来我们看一下ActivityStack.startActivityLocked方法：
```Java
//ActivityStack.java
private final void startActivityLocked(ActivityRecord r, boolean newTask,
        boolean doResume, boolean keepCurTransition) {
    final int NH = mHistory.size();
    int addPos = -1;

    if (!newTask) {
        //目标Activity不是在一个新Task中启动
        boolean startIt = true;
        for (int i = NH-1; i >= 0; i--) {
            ActivityRecord p = mHistory.get(i);
            if (p.finishing) {
                continue;
            }
            if (p.task == r.task) {
                addPos = i+1;
                if (!startIt) {
                    mHistory.add(addPos, r);
                    r.putInHistory();
                    //向WMS添加这个Activity对应的Token
                    mService.mWindowManager.addAppToken(addPos, r.appToken, r.task.taskId,
                            r.info.screenOrientation, r.fullscreen);
                    return;
                }
                break;
            }
            if (p.fullscreen) {
                startIt = false;
            }
        }
    }

    if (addPos < 0) {
        addPos = NH;
    }

    if (addPos < NH) {
        mUserLeaving = false;
    }

    mHistory.add(addPos, r);
    r.putInHistory();
    r.frontOfTask = newTask;
    if (NH > 0) {
        ...
        //向WMS添加目标Activity的Token
        mService.mWindowManager.addAppToken(addPos, r.appToken, r.task.taskId, r.info.screenOrientation, r.fullscreen);
        ...
    } else {
        mService.mWindowManager.addAppToken(addPos, r.appToken, r.task.taskId, r.info.screenOrientation, r.fullscreen);
    }

    if (doResume) {
        resumeTopActivityLocked(null);
    }
}
```
该方法主要是处理与WMS交互的问题：向WMS注册这个Activity，即向WMS添加这个Activity的Token，为显示这个Activity的UI界面做准备。然后就是resumeTopActivityLocked方法来恢复最上层的Activity，并Pause之前的Activity：
```Java
//ActivityStack.java
final boolean resumeTopActivityLocked(ActivityRecord prev) {
    //获取当前正在运行的Activity
    ActivityRecord next = topRunningActivityLocked(null);
    ...

    //如果要启动的Activity就是当前正在运行的Activity，则直接结束
    if (mResumedActivity == next && next.state == ActivityState.RESUMED) {
        mService.mWindowManager.executeAppTransition();
        mNoAnimActivities.clear();
        return false;
    }
    ...

    //从Stop和Sleep中移除目标Activity
    mStoppingActivities.remove(next);
    mGoingToSleepActivities.remove(next);
    next.sleeping = false;
    mWaitingVisibleActivities.remove(next);

    //正在pause上一个Activity
    if (mPausingActivity != null) {
        return false;
    }
    ...

    if (mResumedActivity != null) {
        startPausingLocked(userLeaving, false);
        return true;
    }
    ...

    //如果目标Activity已经创建过，则通知WMS准备显示目标Activity
    if (next.app != null && next.app.thread != null) {
        ...

        try {
            ArrayList a = next.results;
            if (a != null) {
                final int N = a.size();
                if (!next.finishing && N > 0) {
                    next.app.thread.scheduleSendResult(next.appToken, a);
                }
            }
            if (next.newIntents != null) {
                //调用目标Activity的onNewIntent
                next.app.thread.scheduleNewIntent(next.newIntents, next.appToken);
            }

            next.sleeping = false;
            showAskCompatModeDialogLocked(next);
            next.app.pendingUiClean = true;
            //调用目标Activity的onResume
            next.app.thread.scheduleResumeActivity(next.appToken, mService.isNextTransitionForward());

            checkReadyForSleepLocked();
        } catch (Exception e) {
            ...
        }
        ...

    } else {
        ...
        //目标Activity还没有启动，则启动一个进程，启动目标Activity
        startSpecificActivityLocked(next, true, true);
    }
    return true;
}
```
该方法主要包括两个流程：如果目标Activity已经启动过，则直接Resume即可；如果目标Activity还没有启动过，则调用startSpecificActivityLocked启动一个进程，用于启动目标Activity。
```Java
//ActivityStack.java
private final void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) {
    ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid);

    if (r.launchTime == 0) {
        r.launchTime = SystemClock.uptimeMillis();
        if (mInitialStartTime == 0) {
            mInitialStartTime = r.launchTime;
        }
    } else if (mInitialStartTime == 0) {
        mInitialStartTime = SystemClock.uptimeMillis();
    }

    if (app != null && app.thread != null) {
        app.addPackage(r.info.packageName);
        realStartActivityLocked(r, app, andResume, checkConfig);
        return;
    }

    mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,
            "activity", r.intent.getComponent(), false, false);
}
```
该方法中，首先获取目标Activity对应的进程ProcessRecord，如果该进程还处于活跃状态，则只需要让目标进程再创建一个目标Activity并执行即可；否则则需要首先启动一个进程。
```Java
//ActivityManagerService.java
final ProcessRecord startProcessLocked(String processName, ApplicationInfo info,
        boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName,
        boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge,
        String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler) {

    long startTime = SystemClock.elapsedRealtime();
    ProcessRecord app;
    if (!isolated) {
        app = getProcessRecordLocked(processName, info.uid, keepIfLarge);
        checkTime(startTime, "startProcess: after getProcessRecord");
    } else {
        app = null;
    }
    ...

    if (app == null) {
        //创建一个ProcessRecord对象并保存
        app = newProcessRecordLocked(info, processName, isolated, isolatedUid);

        mProcessNames.put(processName, app.uid, app);
        ...
    } else {
        app.addPackage(info.packageName, info.versionCode, mProcessStats);
    }
    ...

    startProcessLocked(app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs);
    return (app.pid != 0) ? app : null;
}
private final void startProcessLocked(ProcessRecord app, String hostingType,
        String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) {
    ...

    mProcessesOnHold.remove(app);

    try {
        int uid = app.uid;
        int[] gids = null;
        int mountExternal = Zygote.MOUNT_EXTERNAL_NONE;
        if (!app.isolated) {
            int[] permGids = null;
            try {
                //从PKMS中查询该进程所属的gid
                final PackageManager pm = mContext.getPackageManager();
                permGids = pm.getPackageGids(app.info.packageName);
                ...
            } catch (PackageManager.NameNotFoundException e) {
                ...
            }
            ...
        }
        ...

        //创建一个新进程
        if (entryPoint == null) entryPoint = "android.app.ActivityThread";
        ...
        Process.ProcessStartResult startResult = Process.start(entryPoint,
                app.processName, uid, uid, gids, debugFlags, mountExternal,
                app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,
                app.info.dataDir, entryPointArgs);
        ...

        app.setPid(startResult.pid);
        app.usingWrapper = startResult.usingWrapper;
        app.removed = false;
        app.killed = false;
        app.killedByAm = false;

        synchronized (mPidsSelfLocked) {
            this.mPidsSelfLocked.put(startResult.pid, app);
            if (isActivityProcess) {
                Message msg = mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);
                msg.obj = app;
                mHandler.sendMessageDelayed(msg, startResult.usingWrapper
                        ? PROC_START_TIMEOUT_WITH_WRAPPER : PROC_START_TIMEOUT);
            }
        }
    } catch (RuntimeException e) {
        ...
    }
}
```
该方法最终创建一个进程，注意进程入口，默认是android.app.ActivityThread类。

### 3.3.3 创建目标进程并初始化
我们直接看ActivityThread的main方法：
```Java
public static void main(String[] args) {
    ...

    Looper.prepareMainLooper();

    ActivityThread thread = new ActivityThread();
    thread.attach(false);

    if (sMainThreadHandler == null) {
        sMainThreadHandler = thread.getHandler();
    }

    Looper.loop();
}
```
该方法首先创建主线程的Looper对象，然后创建ActivityThread对象，并调用其attach方法，建立和AMS的双向通信通道。接下来我们分析一下该方法：
```Java
private void attach(boolean system) {
    sCurrentActivityThread = this;
    mSystemThread = system;
    if (!system) {
        ...
        //建立和AMS的双向通信通道
        final IActivityManager mgr = ActivityManagerNative.getDefault();
        try {
            mgr.attachApplication(mAppThread);
        } catch (RemoteException ex) {
            throw ex.rethrowFromSystemServer();
        }
        ...

    } else {
        //system process的处理
        ...
    }
}
```
AMS在创建一个应用进程后，会设置一个超时时间，如果应用进程未能在该时间内和AMS交互，则AMS认为创建进程失败。所以应用进程启动后会立即和AMS交互，即调用attachApplication方法。

### 3.3.4 AMS进程
上面说到attachApplication方法，该方法直接调用attachApplicationLocked方法，直接看该方法：
```Java
//ActivityManagerService.java
private final boolean attachApplicationLocked(IApplicationThread thread, int pid) {
    ProcessRecord app;
    if (pid != MY_PID && pid >= 0) {
        synchronized (mPidsSelfLocked) {
            app = mPidsSelfLocked.get(pid);
        }
    } else {
        app = null;
    }

    //如果该应用进程由AMS启动，则AMS中有其对应的ProcessRecord，如果找不到，则直接杀掉该进程
    if (app == null) {
        if (pid > 0 && pid != MY_PID) {
            Process.killProcessQuiet(pid);
        }
        ...
        return false;
    }

    if (app.thread != null) {
        handleAppDiedLocked(app, true, true);
    }

    final String processName = app.processName;
    try {
        //创建一个DeathRecipient对象
        AppDeathRecipient adr = new AppDeathRecipient(app, pid, thread);
        thread.asBinder().linkToDeath(adr, 0);
        app.deathRecipient = adr;
    } catch (RemoteException e) {
        ...
    }

    //设置该进程的优先级等
    app.makeActive(thread, mProcessStats);
    app.curAdj = app.setAdj = -100;
    app.curSchedGroup = app.setSchedGroup = Process.THREAD_GROUP_DEFAULT;
    app.forcingToForeground = null;
    updateProcessForegroundLocked(app, false, false);
    app.hasShownUi = false;
    app.debugging = false;
    app.cached = false;
    mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);

    boolean normalMode = mProcessesReady || isAllowedWhileBooting(app.info);
    List<ProviderInfo> providers = normalMode ? generateApplicationProvidersLocked(app) : null;
    try {
        ...
        //通过ApplicationThread对象和应用进程交互，调用其bindApplication方法
        thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,
                profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,
                app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace,
                isRestrictedBackupMode || !normalMode, app.persistent,
                new Configuration(mConfiguration), app.compat, getCommonServicesLocked(),
                mCoreSettingsObserver.getCoreSettingsLocked());
        updateLruProcessLocked(app, false, null);
    } catch (Exception e) {
        ...
    }
    ...

    if (normalMode) {
        try {
            if (mStackSupervisor.attachApplicationLocked(app)) {
                didSomething = true;
            }
        } catch (Exception e) {
            ...
        }
    }
}
//ActivityStackSupervisor.java
final boolean realStartActivityLocked(ActivityRecord r,
        ProcessRecord app, boolean andResume, boolean checkConfig)
        throws RemoteException {
    r.startFreezingScreenLocked(app, 0);
    mWindowManager.setAppVisibility(r.appToken, true);
    r.startLaunchTickingLocked();
    ...

    r.app = app;
    app.waitingToKill = null;
    r.launchCount++;
    r.lastLaunchTime = SystemClock.uptimeMillis();
    int idx = app.activities.indexOf(r);
    if (idx < 0) {
        app.activities.add(r);
    }
    mService.updateLruProcessLocked(app, true, true);

    final ActivityStack stack = r.task.stack;
    try {
        ...
        List<ResultInfo> results = null;
        List<Intent> newIntents = null;
        if (andResume) {
            results = r.results;
            newIntents = r.newIntents;
        }

        if (r.isHomeActivity() && r.isNotResolverActivity()) {
            mService.mHomeProcess = r.task.mActivities.get(0).app;
        }
        mService.ensurePackageDexOpt(r.intent.getComponent().getPackageName());
        r.sleeping = false;
        r.forceNewConfig = false;
        mService.showAskCompatModeDialogLocked(r);
        r.compat = mService.compatibilityInfoForPackageLocked(r.info.applicationInfo);
        ...

        app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_TOP);
        //请求目标进程启动目标Activity
        app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,
                System.identityHashCode(r), r.info,
                new Configuration(mService.mConfiguration), r.compat,
                app.repProcState, r.icicle, results, newIntents, !andResume,
                mService.isNextTransitionForward(), profileFile, profileFd,
                profileAutoStop);
        ...
    } catch (RemoteException e) {
        ...
    }
    ...

    if (isFrontStack(stack)) {
        mService.startSetupActivityLocked();
    }
    return true;
}
```
该方法首先查找到对应应用进程的ProcessRecord对象，并设置一些成员变量，然后从消息队列中撤销PROC_START_TIMEOUT_MSG，然后请求调用目标进程的bindApplication方法，该方法直接调用ActivityThread.handleBindApplication方法，该方法中主要是创建Context、Application对象；然后调用ActivityStackSupervisor.attachApplicationLocked方法完成目标Activity的启动，该方法直接调用realStartActivityLocked方法，其会请求调用目标进程的scheduleLaunchActivity方法。

### 3.3.5 目标进程
我们首先看handleBindApplication方法：
```Java
//ActivityThread.java
private void handleBindApplication(AppBindData data) {
    ...

    //设置进程名
    Process.setArgV0(data.processName);
    android.ddm.DdmHandleAppName.setAppName(data.processName, UserHandle.myUserId());
    ...

    //创建Context对象
    final ContextImpl appContext = ContextImpl.createAppContext(this, data.info);
    updateLocaleListFromAppContext(appContext, mResourcesManager.getConfiguration().getLocales());
    ...

    //初始化Instrumentation对象
    if (ii != null) {
        final ApplicationInfo instrApp = new ApplicationInfo();
        ii.copyTo(instrApp);
        instrApp.initForUser(UserHandle.myUserId());
        final LoadedApk pi = getPackageInfo(instrApp, data.compatInfo,
                appContext.getClassLoader(), false, true, false);
        final ContextImpl instrContext = ContextImpl.createAppContext(this, pi);

        try {
            final ClassLoader cl = instrContext.getClassLoader();
            mInstrumentation = (Instrumentation) cl.loadClass(data.instrumentationName.getClassName()).newInstance();
        } catch (Exception e) {
            ...
        }

        final ComponentName component = new ComponentName(ii.packageName, ii.name);
        mInstrumentation.init(this, instrContext, appContext, component,
                data.instrumentationWatcher, data.instrumentationUiAutomationConnection);
        ...
    } else {
        mInstrumentation = new Instrumentation();
    }

    try {
        //创建Application对象
        Application app = data.info.makeApplication(data.restrictedBackupMode, null);
        mInitialApplication = app;

        //安装该APP中的ContentProvider
        if (!data.restrictedBackupMode) {
            if (!ArrayUtils.isEmpty(data.providers)) {
                installContentProviders(app, data.providers);
                ...
            }
        }
        ...

        mInstrumentation.onCreate(data.instrumentationArgs);

        //调用Application.onCreate方法
        mInstrumentation.callApplicationOnCreate(app);
    } finally {
        ...
    }
}
```
该方法主要初始化一些变量：Context、Intrumentation、Application和ContentProvider等。ActivityStackSupervisor.realStartActivityLocked方法请求该进程执行scheduleLaunchActivity方法启动目标Activity，我们直接看handleLaunchActivity方法：
```Java
//ActivityThread.java
private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) {
    ...

    handleConfigurationChanged(null, null);

    WindowManagerGlobal.initialize();

    //创建目标Activity，并调用其onCreate和onStart方法
    Activity a = performLaunchActivity(r, customIntent);

    if (a != null) {
        r.createdConfig = new Configuration(mConfiguration);
        reportSizeConfigurations(r);
        Bundle oldState = r.state;
        //调用目标Activity的onResume方法
        handleResumeActivity(r.token, false, r.isForward,
                !r.activity.mFinished && !r.startsNotResumed, r.lastProcessedSeq, reason);
        ...
    } else {
        ...
    }
}
private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
    ...

    Activity activity = null;
    try {
        //反射创建目标Activity
        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();
        activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);
        StrictMode.incrementExpectedActivityCount(activity.getClass());
        r.intent.setExtrasClassLoader(cl);
        r.intent.prepareToEnterProcess();
        if (r.state != null) {
            r.state.setClassLoader(cl);
        }
    } catch (Exception e) {
        ...
    }

    try {
        //创建目标Application
        Application app = r.packageInfo.makeApplication(false, mInstrumentation);

        if (activity != null) {
            //创建Context对象
            Context appContext = createBaseContextForActivity(r, activity);
            CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());
            Configuration config = new Configuration(mCompatConfiguration);
            if (r.overrideConfig != null) {
                config.updateFrom(r.overrideConfig);
            }

            Window window = null;
            if (r.mPendingRemoveWindow != null && r.mPreserveWindow) {
                window = r.mPendingRemoveWindow;
                r.mPendingRemoveWindow = null;
                r.mPendingRemoveWindowManager = null;
            }
            //调用目标activity的attach方法，主要是用于和WMS交互
            activity.attach(appContext, this, getInstrumentation(), r.token,
                    r.ident, app, r.intent, r.activityInfo, title, r.parent,
                    r.embeddedID, r.lastNonConfigurationInstances, config,
                    r.referrer, r.voiceInteractor, window);
            ...

            //回调目标Activity的onCreate方法
            if (r.isPersistable()) {
                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);
            } else {
                mInstrumentation.callActivityOnCreate(activity, r.state);
            }

            r.activity = activity;
            r.stopped = true;
            //回调目标Activity的onStart方法
            if (!r.activity.mFinished) {
                activity.performStart();
                r.stopped = false;
            }
            //回调目标Activity的onRestoreInstanceState方法，恢复其状态
            if (!r.activity.mFinished) {
                if (r.isPersistable()) {
                    if (r.state != null || r.persistentState != null) {
                        mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state, r.persistentState);
                    }
                } else if (r.state != null) {
                    mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);
                }
            }
            ...
        }
        r.paused = true;

        mActivities.put(r.token, r);

    } catch (Exception e) {
        ...
    }
    return activity;
}
final void handleResumeActivity(IBinder token,
        boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) {
    ActivityClientRecord r = mActivities.get(token);
    ...

    //回调目标Activity的onResume方法
    r = performResumeActivity(token, clearHide, reason);

    if (r != null) {
        final Activity a = r.activity;
        ...
        //向WMS添加该Activity对应的窗口DecorView
        if (r.window == null && !a.mFinished && willBeVisible) {
            r.window = r.activity.getWindow();
            View decor = r.window.getDecorView();
            decor.setVisibility(View.INVISIBLE);
            ViewManager wm = a.getWindowManager();
            WindowManager.LayoutParams l = r.window.getAttributes();
            a.mDecor = decor;
            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
            l.softInputMode |= forwardBit;
            if (r.mPreserveWindow) {
                a.mWindowAdded = true;
                r.mPreserveWindow = false;
                ViewRootImpl impl = decor.getViewRootImpl();
                if (impl != null) {
                    impl.notifyChildRebuilt();
                }
            }
            if (a.mVisibleFromClient && !a.mWindowAdded) {
                a.mWindowAdded = true;
                wm.addView(decor, l);
            }
        }
        ...

        if (!r.onlyLocalRequest) {
            r.nextIdle = mNewActivities;
            mNewActivities = r;
            //向消息队列中添加一个Idler对象
            Looper.myQueue().addIdleHandler(new Idler());
        }
        r.onlyLocalRequest = false;

        // Tell the activity manager we have resumed.
        if (reallyResume) {
            try {
                ActivityManagerNative.getDefault().activityResumed(token);
            } catch (RemoteException ex) {
                throw ex.rethrowFromSystemServer();
            }
        }

    } else {
        ...
    }
}
```
该方法主要是创建Application、Context、Activity等对象，并回调Activity的相关回调接口，其中穿插着和WMS交互的过程。

### 3.3.6 总结
startActivity的流程相当复杂，我们再简单总结一下其基本流程：
* 首先从调用方开始，直接通过Binder通信进入AMS中，请求AMS启动目标Activity；
* 然后到AMS中，这个流程比较复杂：首先通过调用resolveActivity，由PKMS协助解决目标Activity；然后为目标Activity找到或者创建合适的Task；之后如果当前没有处于finishing的Activity，则回到桌面；否则当mResumedActivity不为空则调用startPausingLocked暂停当前Activity；最后进入startSpecificActivityLocked环节：如果目标进程已存在，则直接启动目标Activity即可；否则需要先为目标Activity创建一个新的进程。
* 目标进程启动后，首先和AMS建立一个双向通信的连接，然后创建Application、Context和目标Activity等，并回调Activity的相关生命周期方法，其中和穿插着和WMS交互。
