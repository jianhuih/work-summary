## 6.6 OOP随谈

### 6.6.1 OOP随谈
首先我们看OOP三要素：封装、继承、多态。

#### 封装
封装的意义，在于明确标识出允许外部使用的所有方法和数据，或者叫接口。

有了封装，就可以明确区分接口（暴露出的方法与成员）和实现，只要接口这个约定不改变，就不影响外部调用者（其具体实现是可以改变的）。问题是建立良好的抽象本身是一件很困难的事情，一般需要我们对相关领域比较了解。

#### 继承和多态
我们首先说继承，其具有两种含义：
1. 继承基类的方法，并基于此扩展自己的逻辑（代码重用）；
2. 声明某个子类兼容于某基类（类型系统），外部调用者可无需关注其具体差别，内部机制会自动把请求派发到合适的逻辑。

多态：基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同。很显然，多态是依附于继承的两种含义的。

实践中，继承的第一种含义（实现继承）常常是有害的，因为它使得子类与基类出现强耦合。继承的第二种含义非常重要，它又叫“接口继承”。接口继承实质上是要求“做出一个良好的抽象，这个抽象规定了一个接口，使得外部调用者无需关心具体实现细节，可统一处理实现了特定接口的所有对象”。就像Linux的文件一样，所有东西都可以当文件处理，不必关心它是内存、磁盘、网络。

#### 总结
面向对象的主要好处实际就这么两点：通过封装区分了接口和实现；通过继承+多态这种内置机制，在语言的层面支持统一抽象设计，使得外部调用者可以以统一的处理方式来处理实现了特定接口的所有对象。

### 6.6.2 设计模式简介
设计模式是一个很大的概念，这里主要谈论GoF的23中设计模式。

#### SOLID
设计模式解决的肯定是系统设计的问题，而系统设计主要是提取抽象、隔离变化。我们先看一下“SOLID”五大原则：
1. S-单一职责原则：一个类/接口只能有一个让它变化的原因。即，将不同的功能隔离开来，不要都混合到一个类中。
2. O-开放封闭原则：对扩展开放，对修改封闭。即，如果遇到需求变化，要通过添加新的类来实现，而不是修改现有的代码。这一点也符合单一职责原则。
3. L-Liskov原则：子类可以完全覆盖父类。
4. I-接口隔离原则：每个接口都实现单一的功能。添加新功能时，要增加一个新接口，而不是修改已有的接口，禁止出现“胖接口”。符合单一职责原则和开放封闭原则。
5. D–依赖倒置原则：这个有两层意思：同层而言：具体依赖于抽象，而非抽象依赖于具体；跨层而言：高层抽象依赖于底层抽象。

总结这些设计原则可知，设计最终关注的还是“抽象”和“隔离”。面向对象的封装、继承和多态，还有每个设计模式，分析它们都离不开这两个词。

#### 对象生命周期
首先我们从面向对象说起：一个对象在系统中的生命周期可以概括为以下几点：
1. 对象创建：就是通过new一个类型来创建对象；
2. 对象组合、包装：一个对象创建后，可能需要对其就行包装或者封装，还可能由多个对象组成一个组合结构；
3. 对象操作：对象创建了，也组合、包装完毕，然后就需要执行对象的各种操作，这是对象真正起作用的阶段。对象的操作情况众多，问题也很多。
4. 对象消亡：直到最后对象消亡，在Java/C#中最终会被GC回收。

与之相对应的是：设计模式可以分为三类：构建模式、结构模式和行为模式
#### 构建模式
首先，我们看一下如何创建对象，构建模式主要有以下四种：
1. 原型：也就是clone接口（Java尽可能不要使用clone接口），Android中的Bitmap的几种原型格式。
2. 单例：该模式有两层意思：唯一变量和全局变量。可以扩展到特殊对象，比如整数中的最大值和最小值。
3. 建造者：将复杂对象的构建和表示相分离，使得同样的构建过程可以创建不同的表示，强调构建过程。Android中的AlertDialog即使用该模式。
4. 工厂方法、简单工厂：这个模式非常有用，将对象的创建过程隔离开，因为对象的创建过程是针对实现编程，容易变化。

#### 结构模式　　
上一节介绍了如何创建一个对象。我们知道任何系统都不可能只有一个对象，一般都需要把对象包装、组合起来使用。与之相对应的就是结构模式：
1. 适配器：使用较多，比较常见。
2. 装饰：主要是增强对象功能，对象功能增强有两种途径：组合和继承，装饰模式主要采用组合的方式，比继承更加灵活。典型例子：Java中I/O设计。
3. 代理：控制真实对象的访问，隐藏其内部具体实现。典型例子：Java RMI，Android中的Binder。
4. 组合：对象层次呈现树状结构，使得用户对单个对象和组合对象的使用具有一致性，有透明版和安全版两种版本。一般常见于GUI系统。
5. 桥梁：抽象和实现相分离，以应对多个方向上的变化，也是以组合代替继承的典型例子。如Android中的AbsListView和ListAdapter。
6. 门面：对子系统的包装，以简化子系统的使用，与入口相对应。Android中的ContextImpl.
7. 享元：细粒度的对象和共享对象（对象池）。Android中Handler的Message对象共享。

#### 行为模式
下面我们就对象操作过程中遇到的一些常见情况做详细的分析：
1. 模板方法：控制反转的典型实现，常用于实现框架。Android中的View体系以及Activity生命周期等。
2. 责任链：关于事件传递有两种方式：默认GUI系统的事件处理，以及Java的ClassLoader的处理逻辑。
3. 状态模式：封装状态以及状态的变化。Android中Bluetooth的各种状态，以及View的相关状态。
4. 命令：将命令封装为函数对象。Android中Handler的post(Runnable)以及Java中Thread和Runnable。
5. 策略：将算法封装为函数对象。Android中动画设置插值算法。
6. 备忘录：封装状态的保存和恢复。Android中Canvas的save和restore以及activity的状态保存等。
7. 中介：多对多的问题。Android中BluetoothAdapter。
8. 观察者：发布-订阅模式。

其他如访问者、解释器和迭代器模式使用较少，这里就不再说明。

### 6.6.3 设计模式思考
设计模式是为了封装变化，让各个模块可以独立变化。准确的使用设计模式的前提是能够预测到需求变更的走向，显然大多数时候是不可能的。这里有两个思路：
1. 深入理解领域知识和领域经验，了解用户使用你的软件是为了解决什么问题，这样你预测用户的需求才会比以前更加准确，从而避免了你使用设计模式来封装一些根本不会发生的变化，也避免了你忽视了未来会发生的变化。
2. 当不确定需求如何变化时，不要过度设计，当需求变更时，使用重构。

需要注意的是，具体的设计模式是和语言强绑定的：
1. 如果语言能把类型像变量一样赋值并传递，很多创建型模式就没用了。
2. 如果语言中函数是一等对象，则很多行为模式没有必要。
2. 如果语言style反对叠床架屋的class hierarchy，很多结构模式就没用了。