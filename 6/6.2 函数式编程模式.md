## 6.2 函数式编程模式

### 6.2.1 高阶函数和闭包
有一个关于闭包和类的笑话：类是穷人的闭包，而闭包则是穷人的类。这个笑话阐明了类和闭包之间关系的一些有意思的事情。在某些方面，闭包和类非常相似。它们都可以承载状态和行为。而在别的方面，它们却又大相径庭。围绕着类有着一整串面向对象的机制，它们定义类型，也可以是类型层次体系中的一部分等等。而闭包则更加简单，它们仅仅是由一个函数和该函数创建时所在的上下文组成的。没有闭包的语言（比如Java）的使用者只能通过使用新建类来完成闭包的工作，所以说类是穷人的闭包。然而，类拥有很多闭包所没有的编程特性，所以说闭包是穷人的类。
拥有闭包和高阶函数可以简化常见的模式（命令模式、模板方法模式和策略模式等），以至于这些模式几乎销声匿迹。闭包和高阶函数非常有用，Java8也引入了lambda表达式。
策略模式和模板方法模式都服务于相似的目的，它们都可以向一个较大规模的框架或算法注入一些自定义代码。不同的是策略模式采用了组合，而模板方法模式采用的是继承。函数式编程中可以使用函数式组合来代替这两种模式。
2. filter-map-reduce
迭代器模式从根本上来说是命令式的，因为它依赖于可变的状态。每个迭代器都在其内部拥有一些状态，这些状态用于保持迭代器对当前位置的跟踪。一旦你将迭代器进行传递，并且你程序的一部分意外地移动了迭代器的指针，从而影响了程序的另一部分，那么这将会为你带来麻烦。相比之下，filter-map-reduce模式实际是将一个序列转换成另一个序列（并不会改变元序列）。事实上，我们在前面讨论的序列推导同时也是单子变换（monadic transformation）技术的几个实例，这一技术经由Haskell这门高度函数式语言的推广而普及，它依赖于一个源自范畴论的概念，称之为单子（monads）。这里我们不再详述这个概念。
3. 操作链模式，流式编程
4. 柯里化
5. 组合
