## 9.1 Xmpp简介

### 9.1.1 简介
Xmpp是一个网络协议，让任何两个或多个网络实体之间进行结构化和可扩展的准实时信息交流。Xmpp协议的扩展性很强，其核心协议是6120，该规范定义了Xmpp的核心协议方法： xml流的配置和解除， 通道加密，验证，错误处理，以及消息通讯基础，网络可用性 ("presence”)和请求-应答交互。主要内容如下所示：

### 9.1.2 Xmpp地址空间
Xmpp地址空间：locale，domain，resource

### 9.1.3 xml流和xml节
一个XML流是一个容器，用于两个实体通过网络交换xml数据，其一般是由一个XML打开标签<stream>(包含适当的属性和名字空间声明)开始的，流的结尾则是一个XML关闭</stream>标签。在流的整个生命周期，初始化它的实体可以通过流发送大量的XML元素，用于流的握手(例如TLS握手或SASL握手)或XML节（在这里指符合缺省名字空间的元素，包括<message/>、<presence/>或者<iq/>元素）。

xml节：Xmpp协议是用来交换xml节，而非任意xml数据。xml节必须是xml流中第一层元素，元素名必须是iq，message，presence；且命名空间必须是“jabber:client”或者“jabber:server”。这三种节提供了Xmpp的基本语义，通过使用xml命名空间扩展基本的节语义，提供附加功能。xml节提供了提供三种不同的通讯原语: 其中iq是“请求-应答”机制用于更结构化的数据交换，message是一个“推送”机制用于已生成的消息,而presence是一个特定的“发布-订阅”机制用于广播网络可用性信息。

从本质上讲：一个XML流作为会话期间发送的XML节的信封，而另一个XML流作为会话期间接收的XML节的信封，我们可以用如下的简化模型做一个展示：
```xml
+--------------------+--------------------+
| INITIAL STREAM     |  RESPONSE STREAM   |
+--------------------+--------------------+
| <stream>           |                    |
|--------------------|--------------------|
|                    | <stream>           |
|--------------------|--------------------|
| <presence>         |                    |
|   <show/>          |                    |
| </presence>        |                    |
|--------------------|--------------------|
| <message to='foo'> |                    |
|   <body/>          |                    |
| </message>         |                    |
|--------------------|--------------------|
| <iq to='bar'       |                    |
|     type='get'>    |                    |
|   <query/>         |                    |
| </iq>              |                    |
|--------------------|--------------------|
|                    | <iq from='bar'     |
|                    |     type='result'> |
|                    |   <query/>         |
|                    | </iq>              |
|--------------------|--------------------|
| [ ... ]            |                    |
|--------------------|--------------------|
|                    | [ ... ]            |
|--------------------|--------------------|
| </stream>          |                    |
|--------------------|--------------------|
|                    | </stream>          |
+--------------------+--------------------+
```

### 9.1.4 xml节的服务端处理规则

#### 顺序处理
一个XMPP服务器必须顺序处理它从一个已连接的客户端或远端服务器的给定的入站流上收到的节和其他XML元素:
1. 由一个客户端发送到它的服务器或它自己的纯JID的由服务器直接处理的节(例如：XMPP‑IM中的获取好友名册和初始化出席信息的顺序处理)。
2. 由一个已连接的客户端发送的节并且是用来递送到另一个和该服务器相关的实体(例如：从地址<juliet@im.example.com>发到<nurse@im.example.com>的节)。服务器必须确保按照从发送的客户端的入站流上接收到节的顺序来递送那些到预期接收者的节，对递送目的接收者地址为纯JID和全JID的节等同对待。
3. 由一个已连接的客户端发送的节并且是用来递送到一个位于远端服务器上的实体(例如：从地址<juliet@im.example.com>发到<romeo@example.net>)。路由服务器必须确保按照从发送的客户端的入站流上接收到节的顺序来路由那些到预期接收者的节，对路由目的接收者地址为纯JID和全JID的节等同对待。为了确保顺序处理，路由服务器必须通过单一的到远端域的出站流（同一条连接上）来路由这些节，而不是在一个服务器－服务器流上发送一些节而在另一个服务器－服务器流上发送另一些节。
4. 从一个服务器路由到另一个服务器的递送到远端服务器的一个相关实体的节(例如：从地址<juliet@im.example.com>发到<romeo@example.net>并且由<im.example.com>在一个服务器－服务器流上路由到<example.net>)。递送服务器必须确保按照它从路由服务器的入站流上接收到的顺序来递送这些xml节，对递送目的接收者地址为纯JID和全JID的节同等对待。
5. 由一个服务器发送到另一个服务器用于远端域直接处理的节(例如：从<im.example.com>发到<example.net>)。

需要注意的是：顺序处理只适用于单一入站流，所以服务器不保证它从相同本地帐号的两个不同入站流的顺序处理，一般服务器可以以<conflict/>流错误来关闭该流。

#### 一般注意事项
服务器处理XML节有三个主要的注意事项，:
1. 尽可能地把一个节递送到预定的接收者。
2. 如果一个节不能被递送，应该通知发送者。
3. 不应该促成目录获取攻击和联机状态泄露。

#### 没有'to'地址
如果一个xml节没有'to'属性，服务器必须代表发送它的实体来直接处理它。因为从其它服务器收到的所有节必须拥有'to'属性，因此该规则只适用于从连接到该服务器的本地实体(一般是一个客户端)收到的节。
1. Message
如果该服务器接收到一个没有'to'属性的message节，它必须把这个消息当作'to'地址是发送实体的纯JID<localpart@domainpart>那样来处理。
2. Presence
如果该服务器接收到一个没有'to'属性的presence节，它必须广播这个节到订阅了发送者实体的出席信息的实体(XMPP‑IM定义了出席信息应用的这类广播的语义)。
3. IQ
如果服务器接收到一个没有'to'属性的iq节，它必须代表发送这个节的帐户处理这个节，具体处理规则如下:
如果iq节的类型为"get"或"set"并且服务器理解payload的命名空间，该服务器必须代表发送实体处理该节或返回一个适当的错误给发送实体。例如：如果发送实体发送一个类型为"get"而payload是由'jabber:iq:roster'命名空间限定(参见XMPP‑IM)的iq节，那么服务器将返回和该发送实体的纯JID相关的roster给请求roster的发送实体的特定资源。
如果iq节的类型为"get"或"set"并且服务器不理解限定该payload的命名空间，服务器必须返回一个错误给发送实体，这个错误必须是<service-unavailable/>。
如果iq节的类型是"error"或"result"，该服务器必须根据该iq相关的payload的类型是"get"或"set"处理这个error或result(如果没有相关的节，服务器必须忽略该error或result节)。

### 9.1.5 通信基本流程：
客户端-服务器示例：
1. 建立TCP连接（一般要进行DNS解析，BOSH也可作为其底层连接方式）
2. 打开xml流
3. TLS加密，SASL验证
4. 绑定资源
5. 交换xml节
6. 关闭xml流，关闭TCP连接

服务器-服务器示例：
1. 建立TCP连接（一般要进行DNS解析，BOSH也可作为其底层连接方式）
2. 打开xml流
3. TLS加密，SASL验证
4. 交换xml节
5. 关闭xml流，关闭TCP连接

### 9.1.6 Xmpp协议的扩展：
Xmpp是一个关于传输Xml数据的网络协议，该协议定义了三种Xml节：presence，iq和message。其中presence是出席消息（其主要语义是PubSub），iq是请求应答交互（类似于Http基本语义），message是消息（fire-forget），它们构成了Xmpp协议的基本语义。Xmpp只能发送这三种Xml数据，具体应用通过这三种Xml节中定义子元素（xml命名空间）进行扩展以实现自己的通信语义：其中message，presence可以包括一个或多个子元素，而iq（set，get）必须包括一个子元素，该子元素可以使用任何名称且必须拥有一个命名空间（不能是“jabber:client”，“jabber:server”以及stream）。

### 9.1.7 PubSub
这里我们看一个扩展协议PubSub，该扩展协议使Xmpp实体能在一个pubsub服务上创建节点(主题)并发布信息到那些节点上；然后一个事件通知(携带或未带载荷)被广播到所有订阅了该节点的实体。

PubSub使用了经典的 "发布-订阅" 或曰 "观察者" 设计模式： 一个人或应用发布信息，同时一个事件通知 (包含或不包含有效载荷) 被广播到所有授权的订阅者。通常， 发布者和订阅者之间的联系是由一个服务来调节的，这个服务接收发布请求，广播事件通知到订阅者，并允许特许实体能管理被授权发布或订阅的人员或应用的列表。对于发布和订阅的焦点是一个节点 "node" ，它是发布者发送数据的目的地，也是订阅者接收通知的目的地。节点也维护一个事件历史并提供其他服务以补充纯的pubsub模式。

其基本的思路是简单的:
一个实体发布信息到一个pubsub服务上的一个节点。
pubsub服务推送一个事件通知到所有被授权可以得知该发布信息的实体。

一、基本概念
从属关系：所有者，发布者，订阅者，普通实体
订阅状态
事件类型：两个维度：持久性和临时性，纯通知和包含负载的通知。所有者可以从这两个维度配置一个节点。持久性节点要求必须有itemID，节点必须保存该item（实体可以从节点请求已有的item）。需要注意的是，无论一个节点是配置持久性还是临时性的事件，pubsub服务都可以缓存最后发布到节点的条目
节点类型
节点访问模式
寻址：

如果一个pubsub节点是可设定地址的，则必须是一个JID或一个JID和一个节点的组合。

二、具体用例
实体用例：查询节点相关信息：节点，节点信息，节点元数据，节点item；找回订阅，找回从属关系
订阅者用例：订阅节点，取消订阅，配置订阅选项，请求缺省订阅配置选项，从节点获取item
发布者用例：发布item到节点，从节点删除item
所有者用例：管理节点，管理订阅，管理从属关系
