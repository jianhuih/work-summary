## 7.9 P2P协议详解

### 7.9.1 P2P穿越NAT的几种方案

P2P即点对点通信，或称为对等联网，与传统的C/S模式有着明显的区别。在P2P网络中所有通信节点的地位都是对等的，每个节点都扮演着客户机和服务器双重角色，节点之间通过直接通信实现文件信息、处理器运算能力、存储空间等资源的共享。P2P网络具有分散性、可扩展性、健壮性等特点，这使得P2P技术在信息共享、实时通信、协同工作、分布式计算、网络存储等领域都有广阔的应用。

由IPv4地址资源的紧缺使得NAT技术获得了广泛的应用。NAT技术是一种把内部网络（简称为内网）私有IP地址转换为外部网络（简称为外网）公共IP地址的技术，它使得一定范围内的多台主机只利用一个公共IP地址连接到外网，可以在很大程度上缓解了公网IP地址紧缺的问题。NAT技术虽然在一定程度上解决了IPv4地址短缺的问题，在构建防火墙、保证网络安全方面都发挥了一定的作用，却破坏了端到端的网络通信。NAT阻碍主机进行P2P通信的主要原因是NAT不允许外网主机主动访问内网主机，因为NAT设备上没有相关转发表项，要在NAT网络环境中进行有效的P2P通信，就必须寻找相应的解决方案。本文就着重介绍几种常见的解决方案。

### 7.9.2 反向链接技术
当通信的双方中只有一方位于NAT之后时，它们可以利用反向链接技术来进行P2P通信。图3中ClientA（拥有内网IP地址10.0.0.1）位于NAT之后，它通过TCP端口1234连接到服务器的TCP端口1235上，NAT设备（拥有外网IP地址155.99.25.11）为这个连接重新分配了TCP端口62000。ClientB（拥有外网IP地址138.76.29.7）也通过TCP端口1234连接到服务器端口1235上。ClientA和ClientB从服务器处获知的对方的外网地址二元组{IP地址:端口号}分别为{138.76.29.7:1234}和{155.99.25.11:62000}，它们在各自的本地端口上进行侦听。
由于ClientB拥有外网IP地址，所以ClientA要发起与ClientB的通信，那么它可以直接通过TCP连接到ClientB。但如果ClientB尝试通过TCP连接到ClientA进行P2P通信，则会失败，原因是ClientA位于NAT设备后，虽然ClientB发出的TCP SYN请求能够到达NAT设备的端口62000，但NAT设备会拒绝这个连接请求。要想与ClientA通信，ClientB要通过服务器给ClientA转发一个连接请求，反过来请求ClientA连接到ClientB（即进行反向链接），从而建立起它们之间的TCP连接。

![reverse-connection](../img/7-10-reverse-connection.jpg)

### 7.9.3 UDP打洞技术
如果两个P2P客户端都位于NAT设备后面，想要进行P2P通信，那又该如何解决呢？UDP打洞技术就是为解决这个问题而应运而生的，它能够通过中间服务器实现P2P客户端互连。该技术在RFC3027的第5.1节中有所提及，接下来我们将会详细介绍该技术：

#### 集中服务器
打洞技术假定ClientA和ClientB都可以与集中服务器建立UDP连接，一个客户端在集中服务器上登陆的时候，服务器记录下该客户端的两个地址信息（IP地址和端口号），一个是该客户端的内网IP地址和端口号，另一个是该客户端的内网IP地址和端口号经过NAT转换后的外网IP地址和端口号。集中服务器可以从客户端的登陆消息中得到该客户端的内网地址信息，还可以通过登陆消息的IP首部和UDP首部得到该客户端的外网地址信息。如果该客户端不是位于NAT设备后面，那么采用上述方法得到的两对地址二元组信息是相同的。

#### 建立P2P的Session
假定ClientA要发起对ClientB的直接连接，具体的“打洞”过程如下：
1. ClientA最初不知道如何向ClientB发起连接，于是ClientA向集中服务器发送消息，请求集中服务器帮助建立与ClientB的UDP连接。
2. 集中服务器会将ClientB的外网地址和内网地址发给ClientA，将ClientA的外网地址和内网地址发给ClientB。这样一来，ClientA与ClientB就都知道对方外网地址和内网地址。
3. 当ClientA收到由集中服务器发来的包含ClientB的外网地址和内网地址信息后，ClientA开始向ClientB的外网地址和内网地址发送UDP数据包，并且自动锁定第一个给出响应的ClientB的地址。同理，当ClientB收到由集中服务器发来的ClientA的外网地址和内网地址信息后，也会开始向ClientA的外网地址和内网地址发送UDP数据包，并且自动锁定第一个得到ClientA回应的地址。由于ClientA与ClientB互相向对方发送UDP数据包的操作是异步的，所以ClientA和ClientB发送数据包的时间先后并没有时序要求。
接下来我们分三种具体情景来进行讨论：
第一种是最简单的一种情景，两个客户端都位于同一个NAT设备后面，即位于同一内网中；
第二种是最普遍的一种情景，两个客户端分别位于不同的NAT设备后面，分属不同的内网；
第三种是客户端位于两层NAT设备之后，通常最上层的NAT是由网络提供商提供的，第二层NAT是家用的NAT路由器之类的设备提供的。

#### P2P的两个客户端位于同一个NAT设备后面
当ClientA和ClientB位于同一个NAT设备后面，如下图所示。ClientA与集中服务器建立了UDP连接，经过NAT转换后，A的公网端口被映射为62000。ClientB同样与集中服务器建立了UDP连接，公网端口映射为62005。

![udp-same-nat](../img/7-10-udp-same-nat.png)

上文中，我们说过ClientA和ClientB同时向对方外网和内网地址发送UDP数据包，发往对方外网地址的UDP数据包不一定会被对方收到，这取决于当前的NAT设备是否支持不同端口之间的UDP数据包能否到达即Hairpin转换特性，但是发往对方内网地址的UDP数据包是一定可以到达的，而且内网数据包直接进行交付（处于同一个局域网中）。即使NAT设备支持Hairpin转换，仍然优先考虑使用内网地址进行P2P通信，因为这样开销更小。

#### P2P客户端位于不同的NAT设备后面
当ClientA与ClientB在不同的NAT设备后面，分属不同的内网，如下图所示。ClientA与ClientB都经由各自的NAT设备与集中服务器建立了UDP连接，ClientA与ClientB的本地端口号均为4321，集中服务器的公网端口号为1234。在向外的会话中，ClientA的外网IP被映射为155.99.25.11，外网端口为62000，ClientB的外网IP被映射为138.76.29.7，外网端口为31000。
如下所示：
ClientA：内网地址：10.0.0.1:4321，外网地址：155.99.25.11:62000
ClientB：内网地址：10.1.1.3:4321，外网地址：138.76.29.7:31000

![udp-diff-nat](../img/7-10-udp-diff-nat.png)

A、B分属不同的内网，所以发往各自内网地址的UDP数据包会发送到错误的主机或者根本不存在的主机上。现在我们来分析发往外网地址的情况，如上图所示：首先我们看一下A向B的外网地址发送UDP数据包时，该消息途经A的NAT设备时，会在该设备上生成一个10.0.0.1:4321－>138.76.29.7:31000的会话，如果A的NAT设备给出的响应是OK的，那么A的NAT设备将保留A的内网地址信息。A向B的外网地址发送消息的过程就是“打洞”的过程，从A的内网地址来看是10.0.0.1:4321发往138.76.29.7:31000，从A的NAT设备上建立的会话来看，是从155.99.25.11:62000发到138.76.29.7:31000。
如果A发给B的外网地址的数据包在B向A发送数据包之前到达B的NAT设备，B的NAT设备会认为A发过来的消息是未经授权的外网消息，会丢弃掉该数据包。B发往A的消息包与上述的过程一样，会在B的NAT设备上建立一个10.1.1.3:4321－>155.99.25.11:62000的会话（通常也会沿用B与集中服务器连接时建立的会话，只是该会话现在不仅接受由服务器发给B的消息，还可以接受从A的NAT设备155.99.25.11:6200发来的消息），一旦A与B都向对方的外网地址发送了数据包，就打开了A与B之间的“洞”，然后进行正常的数据传输。

#### P2P客户端位于多层NAT设备后面
现在我们来讨论最后一种情况，如下图所示：假定NAT C是由ISP提供的NAT设备，NAT C提供将多个用户节点映射到有限的几个公网IP的服务，NAT A和NAT B作为NAT C的内网节点将把用户的家庭网络或内部网络接入NAT C的内网，然后用户的内部网络就可以经由NAT C访问公网了。从这种拓扑结构上来看，只有服务器与NAT C是真正拥有公网IP地址的设备。ClientA和ClientB发起对服务器的连接时，就会依次在NAT A和NAT B上建立向外的Session，而NAT A、NAT B要连入公网的时候，会在NAT C上再建立向外的Session。

![udp-2-layer-nat](../img/7-10-udp-2-layer-nat.png)

现在ClientA和B希望通过UDP打洞完成两个客户端的P2P直连，最优化的路由策略是ClientA向ClientB的“公网”地址上发送数据包，即NAT C指定的内网地址，NAT B的“公网”地址10.0.1.2:55000。由于从服务器的角度只能观察到真正的公网地址，也就是NAT A，NAT B在NAT  C建立session的真正的公网地址155.99.25.11:62000以及155.99.25.11:62005，所以ClientA与ClientB是无法通过服务器知道这些“公网”地址，而且即使ClientA和ClientB通过某种手段可以得到NAT A和NAT B的“公网”地址，我们仍然不建议采用上述的“最优化”的打洞方式，这是因为这些地址是由ISP服务提供商提供的或许会存在与客户端本身所在的内网地址重复的可能性，这样将导致打洞失败。

此时客户端别无选择，只能使用由公网服务器观察到的A，B的公网地址进行“打洞”操作，用于“打洞”的数据包将由NAT C进行转发。
当ClientA向ClientB的公网地址155.99.25.11:62005发送UDP数据包的时候，NAT A首先把数据包的源地址由A的内网地址10.0.0.1:4321转换为“公网”地址10.0.1.1:45000，然后数据包到了NAT C，NAT C将识别出该数据包是要发往自身的，如果NAT C支持Hairpin转换，NAT C将把该数据包的源地址改为155.99.25.11:62000，目的地址改为10.0.1.2:55000，即NAT B的“公网”地址，最后NAT B会将收到的数据包发往ClientB。同样，由ClientB发往ClientA的数据包也会经过类似的过程。

#### UDP在空闲状态下的超时问题
需要注意的是：一般NAT设备的地址转换表都会有一个超时时间（中国移动，联通一般是5分钟），超时后，NAT设备删除该项地址转换表。所以一般需要心跳包对抗该超时。

### 7.9.4 TCP打洞技术
建立穿越NAT设备的P2P的TCP连接比UDP稍微复杂一些，从协议层来看TCP的“打洞”与UDP的“打洞”过程是非常相似的。而且TCP是面向连接的，也会比UDP更加可靠。

#### 套接字和端口的重用
实现基于TCP协议的P2P打洞过程中，最主要的问题不是来自于TCP协议，而是来自于应用程序的Socket API，Socket API是围绕着构建客户端/服务器程序而设计的，一般客户端调用connect函数主动连向服务端，服务端调用listen和accept函数接受来自客户端的连接。其API不支持在同一个端口既可以主动向外连接，又能够被动接受外部的连接。为了让TCP“打洞”顺利进行，我们需要使用同一个端口来监听来自外部的连接请求，同时主动向外发起连接请求。幸运的是，所有的主流操作系统都能够支持特殊的TCP套接字参数，通常叫做“SO_REUSEADDR”，该参数允许应用程序将多个套接字绑定到同一个端口。

#### 打开P2P的TCP流
假定ClientA希望建立与B的TCP连接，服务器记录下来每个接入的客户端的外网和内网地址，如同为UDP服务的时候一样。从协议层来看，TCP“打洞”与UDP“打洞”是几乎完全相同的过程。
1. 首先仍然是服务器将ClientB的外网和内网地址发送给ClientA，同时将ClientA的外网和内网地址发送给ClientB；
2. ClientA和ClientB使用连接服务器的端口发起向对方的外网、内网地址的连接请求，同时监听该端口是否有外部的连接请求；
3. ClientA和ClientB开始等待向外的连接是否成功，同时检查是否有连接请求连入。如果向外的连接由于某种网络错误而失败，如：“连接被重置”或者“节点无法访问”，客户端只需要延迟一小段时间，然后重新发起连接即可；
4. TCP连接建立起来以后，客户端之间应该开始鉴权操作，确保目前连入的连接就是所希望的连接。如果鉴权失败，客户端将关闭连接，并且继续等待新的连接连入。客户端通常采用“先入为主”的策略，只接受第一个通过鉴权操作的客户端，然后将进入P2P通信过程不再继续等待是否有新的连接连入。

#### 从应用程序的角度来看TCP打洞
从应用程序的角度来看，在进行TCP“打洞”的时候都发生了什么呢？假定ClientA调用connect函数向ClientB的外网地址发出SYN包，会被ClientB的NAT设备丢弃，但是ClientB发往ClientA的外网地址的SYN包则通过ClientA的NAT到达了ClientA，然后会发生以下的两种结果中的一种，具体是哪一种取决于操作系统对TCP协议的实现：
1. ClientA会发现收到的SYN包就是其发起连接并希望连入的ClientB的SYN包，通俗一点来说就是“说曹操，曹操到”的意思，本来ClientA要去找ClientB，结果ClientB自己找上门来了。ClientA调用的异步connect函数将成功返回，连接建立，可以进行正常的数据通信了。而ClientA调用的listen等待从外部连入的函数将没有任何反应。
但是此时由于收到的SYN包中不包含ClientA需要的ACK数据，因此ClientA的TCP将用SYN-ACK包回应收到的SYN包，并且将使用先前ClientA发向ClientB的SYN包一样的序列号。一旦ClientB收到由ClientA发来的SYN-ACK包，则把自己的ACK包发给ClientA，然后两端建立起TCP连接。简单的说，第一种，就是即使ClientA发往ClientB的SYN包被ClientB的NAT丢弃了，但是由于ClientB发往ClientA的包到达了ClientA。其结果是仍然完成了三步握手，连接成功建立，可以进行正常通信。
2. ClientA的TCP实现没有发现收到的SYN包就是自己希望连入的，然后，ClientA通过之前调用的listen函数和accept函数建立起与ClientB的连接，可以使用该连接进行正常通信。而由ClientA主动发起的向ClientB的连接请求则会失败。

BSD操作系统会按照第一种情况处理，而Linux合Windows会按照第二种情况处理。

### 7.9.5 NAT简介
NAT是在IP地址日益缺乏的情况下提出的，主要是为了能够地址重用。目前的地址转换协议主要有基本的NAT和NAPT两类：前者只会转换IP地址，而后者会转换IP地址和端口。根据STUN标准（RFC3489），NAT可以分为以下四类：

#### Full Cone
这种NAT内部的主机A连接过外网主机C后，NAT会打开一个端口，然后任何外网主机发到这个端口的UDP数据报都可以到达主机A，不管是不是主机C发过来的。

A(192.168.8.100:5000) -> NAT(202.100.100.100 : 8000) -> C(292.88.88.88:2000)
任何发送到NAT(202.100.100.100:8000)的数据都可以到达主机A(192.168.8.100:5000)

#### Restricted Cone
这种NAT内部的主机A连接过外网主机C后，NAT打开一个端口，然后C可以用任何端口和A通信，而其他的外网机器不行。

A(192.168.8.100:5000) -> NAT(202.100.100.100 : 8000) -> C(292.88.88.88:2000)
任何从主机C发送到NAT(202.100.100.100:8000)的数据都可以到达主机A(192.168.8.100:5000)

#### Port Restricted Cone
这种NAT内部的主机A连接过外网主机C后，NAT打开一个端口，然后C可以用该端口和A通信，但是C不可以使用其他端口和A通信，其他的外网机器也不行。

A(192.168.8.100:5000) -> NAT(202.100.100.100 : 8000) -> C(292.88.88.88:2000)
主机C(202.88.88.88:2000)发送到NAT(202.100.100.100:8000)的数据都可以到达主机A(192.168.8.100:5000)

以上三种NAT通称Cone NAT，我们只能用这种NAT进行UDP打洞。

#### Symmetric

对于这种NAT，连接不同的外部目标，原来NAT打开的端口会变化，而Cone NAT不会。这种方式NAT只能通过端口猜测的方式进行UDP打洞，成功概率较低。
